# JPA_Basic
## JPA 소개
### SQL 중심적인 개발의 문제점
- 객체답게 모델링 할수록 매핑 작업만 늘어난다
- 무한 반복, 지루한 코드
- 필드 추가시 모든 관련 SQL 쿼리 수정

#### 객체와 관계형 데이터베이스의 차이
- 상속
- 연관관계 : 객체 = 단방향 / 테이블 = 양방향
- 데이터 타입
- 데이터 식별 방법

### JPA
- 자바 진영의 ORM 기술 표준
- 애플리케이션과 JDBC 사이에서 동작
- 엔티티를 분석해서 SQL 생성
- SQL를 생성해서 엔티티로 결과반환
- JPA는 인터페이스의 모음
- JPA 표준 명세를 구현한 3가지 구현체
  - 하이버네이트 
  - EclipseLink
  - DataNucleus 

#### ORM
- 객체 관계 매핑
- 객체는 객체대로 설계
- 관계형 데이터베이스는 관계형 데이터베이스대로 설계
- ORM 프레임워크가 중간에서 매핑

#### JPA를 왜 사용해야 하는가?
- 객체 중심으로 개발 가능
- 생산성
- 유지보수
- 패러다임의 불일치 해결
  - 상속 
    - 저장 : 부모 insert문 자식 insert문 생성
    - 조회 : 조인 쿼리문 생성
    - 연관관계, 객체 그래프 탐색 : 컬랙션 형태로 탐색가능
- 신뢰할 수 있는 엔티티, 계층
- JPA의 성능 최적화 기능
  - 1차 캐시와 동일성 보장 : 같은 트랜잭션 안에서는 같은 엔티티를 반환 = 한 번 실행한 SQL은 다시 실행 안한다
  - 트랜잭션을 지원하는 쓰기 지연 : 트랜잭션을 커밋할 때 까지 insert문을 모은다
  - 지연 로딩 : 객체가 실제 사용될 때 로딩
  - 즉시 로딩 : JOIN SQL로 한번에 연관된 객체까지 미리 조회

## JPA 시작하기
- 엔티티 매니저 팩토리는 하나만 생성해서 애플리케이션 전체에서 공유
- 엔티티 매니저는 쓰레드간의 공유 X (사용하고나면 버려야 한다)
- JPA의 모든 데이터 변경은 트랜잭션 안에서 실행

## 영속성 관리 - 내부 동작 방식
### 영속성 컨텍스트
- 엔티티를 영구 저장하는 환경
- 엔티티 매니저를 통해서 접근

#### 엔티티의 생명주기
- 비영속 : 영속성 컨텍스트와 전혀 관계 없는 새로운 상태
- 영속 : 영속성 컨텍스트에 관리되는 상태
- 준영속 : 영속성 컨텍스트에 저장되었다가 분리된 상태
- 삭제 : 삭제된 상태

#### 1차 캐시에서 조회
한 번 조회한 쿼리 데이터는 쿼리에 저장해놓고 중복 조회를 하지않는다

#### 영속 엔티티의 동일성 보장
한 번 조회한 것은 1차 캐시에서 가져오기 때문에 동일성이 보장된다

#### 트랜잭션을 지원하는 쓰기 지연 ( 엔티티 생성 )
insert 쿼리가 트랜잭션 커밋 시점에 실행된다.

#### 변경 감지 ( 엔티티 수정 )
1차캐시에 있는 데이터가 변경되면 update 쿼리 생성

### 플러시
영속성 컨텍스트의 변경내용을 데이터베이스에 반영  
트랜잭션이라는 작업 단위가 중요  
커밋 직전에만 동기화 하면 됨

#### 플러시 밣생
- 변경 감지
- 수정된 엔티티 쓰기 지연 SQL 저장소에 등록
- 쓰기 지연 SQL 저장소의 쿼리를 데이터베이스에 전송(등록, 수정, 삭제 쿼리)

#### 영속성 컨텍스트를 플러시하는 방법
- em.flush() : 직접 호출
- 트랜잭션 커밋 : 플러시 자동 호출
- JPQl 쿼리 실행 : 플러시 자동 호출

### 준영속 상태
영속성 컨텍스트의 기능을 사용하지 못하게 된다

#### 준영속 상태 만드는법
- em.detach : 특정 엔티티만 준영속 상태 만들기
- em.clear : 영속성 컨텍스트 완전 초기화
- em.close : 영속성 컨텍스트 종료

## 엔티티 매핑
### 엔티티 매핑 소개
- 객체와 테이블 매핑 : @Entity, @Table
- 필드와 컬럼 매핑 : @Column
- 기본 키 매핑 : @Id
- 연관관계 매핑 : @ManyToOne, @JoinColumn

### @Entity : JPA가 관리하는 엔티티
- 기본 생성자 필수( 파라미터가 없는 public 또는 protected 생성자)
- final 클래스, enum, interface, inner 클래스 사용 X
- 저장할 필드에 final 사용 X

### @Table : 엔티티와 매핑할 테이블 지정
속성 리스트
- name : 매핑할 테이블 이름
- catalog : DB catalog 매핑
- schema : DB 스키마 매핑
- uniqueConstraints : DDL 생성 시에 유니크 제약 조건 생성

### 데이터베이스 스키마 자동 생성
- DDL을 애플리케이션 실행 시점에 자동 생성
- 테이블 중심 -> 객체 중심
- 데이터베이스 방언을 활용해서 적절한 DDL 생성
- DDL은 개발 장비에서만 사용
- DDL은 운영서버에서는 사용하지 않거나, 적절히 다듬은 후 사용

#### 속성
hibernate.hbm2ddl.auto
- create : 기존테이블 삭제 후 다시 생성
- create-drop : create와 같으나 종료시점에 테이블 drop
- update : 변경분만 반영(운영DB에는 사용하면 안됨)
- validate : 엔티티와 테이블이 정상 매핑되었는지만 확인
- none : 사용하지않음

#### 주의
- create, create-drop, update는 운영 장비에는 절대 사용하면 안된다
- 개발 초기 단계 : create, update
- 스테이징과 테스트 서버 : update, validate
- 운영 서버 : none

### 필드와 컬럼 매핑
- @Column : 컬럼 매핑
- @Temporal : 날짜 타입 매핑
- @Enumerated : enum 타입 매핑
- @Lob : BLOB, CLOB 매핑
- @Transient 특정 필드를 컬럼에 매핑하지 않음

#### @Column
속성
- name : 필드와 매핑할 테이블의 컬럼 이름
- insertable, updatable : 등록, 변경 기능 여부
- nullable(DDL) : null 값의 허용 여부를 설정한다
- unique(DDL) : 한 컬럼에 간단히 유니크 제약조건을 걸 때 사용 (@Table의 uniqueConstraints를 쓰고 해당 속성은 잘 사용하지 않는다)
- columnDefinition(DDL) : 데이터베이스 컬럼 정보를 직접 줄 수 있다.
- length(DDL) : 문자 길이 제약조건, String 타입에만 사용가능
- precision, scale(DDL) : 매우 큰 숫자나 정밀한 소수를 다룰 때 사용(precision은 소수점을 포함한 전체 자릿수, scale은 소수의 자릿수)

##### @Temporal
날짜 타입을 매핑할 때 사용  
LocalDate, LocalDateTime을 사용할 때는 생략  
속성
- value
  - TemporalType.DATE : 예) 2013-10-11
  - TemporalType.TIME : 예) 11:11:11
  - TemporalType.TIMESTAMP : 예) 2013-10-11 11:11:11

#### @Enumerated
EnumType.ORDINAL은 사용하지 않는다

#### @Lob
매핑하는 필드 타입이 문자면 CLOB 나머지는 BLOB

#### @Transient
메모리상에서만 임시로 값을 보관하고 싶을 때 사용

### 기본 키 매핑
#### 기본 키 매핑 어노테이션
- @Id
- @GeneratedValue

#### 기본 키 매핑 방법
- 직접 할당 : @Id만 사용
- 자동 생성(@GeneratedValue)
  - IDENTITY: 데이터베이스에 위임, MYSQL (ID값을 알기 위해 지연 로딩 사용 불가)
  - SEQUENCE: 데이터베이스 시퀀스 오브젝트 사용, ORACLE
    - @SequenceGenerator 필요
    - allocationSize 속성으로 미리 지정한 갯수만큼 불러와서 메모리에서만 사용하는 식으로 최적화 가능
  - TABLE: 키 생성용 테이블 사용, 모든 DB에서 사용
    - @TableGenerator 사용
    - allocationSize 속성으로 미리 지정한 갯수만큼 불러와서 메모리에서만 사용하는 식으로 최적화 가능
  - AUTO: 방언에 따라 자동 지정, 기본값

#### 권장하는 식별자 전략
Long형 + 대체키 + 키 생성전략 사용

## 연관관계 매핑 기초
### 양방향 매핑 규칙
- 객체의 두 관계중 하나를 연관관계의 주인으로 지정
- 연관관계의 주인만이 외래 키를 관리
- 주인이 아닌쪽은 읽기만 가능
- 주인은 mappedBy 속성 사용 X
- 주인이 아니면 mappedBy 속성으로 주인 지정
- FK가 있는 엔티티를 주인으로 정해라

### 양방향 연관관계 주의
- 순수 객체 상태를 고려해서 항상 양쪽에 값을 설정하자
- 연관관계 편의 메소드를 생성하자 예) Member클래스에 setTeam메서드 team.getMembers().add(this);
- 양방향 매핑시에 무한 루프를 조심하자

### 양방향 매핑 정리
- 설계 시점에 단방향 매핑만으로 끝낸다
- 반대 방향은 조회 기능만 추가한다는 생각으로 추가한다

## 다양한 연관관계 매핑
### 다대일 [N:1]
- 외래 키(FK)가 있는 쪽이 연관관계의 주인
- 양쪽을 서로 참조하도록 개발

### 일대다 [1:N]
####왠만하면 다대일 양방향 매핑을 사용하자
- 일대다 단방향은 1이 연관관계의 주인
- 테이블 일대다 관게는 항상 N 쪽에 외래 키가 있음
- 객체와 테이블의 차이 때문에 반대편 테이블의 외래 키를 관리하는 특이한 구조
- @JoinColumn을 꼭 사용해야함 그렇지 않으면 중간에 테이블을 하나 추가한다

단점 
- 엔티티가 관리하는 외래키가 다른 테이블에 있음
- 연관관계 관리를 위해 추가로 update sql 실행

### 일대일 [1:1]
- 외래 키(FK)가 있는 곳이 연관관계 주인
- 반대편은 mappedBy 적용

#### 주 테이블에 외래 키
- 주 테이블에 외래 키를 두고 대상 테이블을 찾음
- 객체지향 개발자 선호
- JPA 매핑 편리
- 장점 : 주 테이블만 조회해도 대상 테이블에 데이터가 있는지 확인 가능
- 단점 : 값이 없으면 외래 키에 null 허용

#### 대상 테이블에 외래 키
- 대상 테이블에 외래 키가 존재
- 전통적인 DB 개발자 선호
- 장점 : 주 테이블과 대상 테이블을 일대일에서 일대다 관계로 변경할 때 테이블 구조 유지
- 단점 : 프록시 기능의 한계로 지연 로딩으로 설정해도 항상 즉시 로딩됨

### 다대다 [N:N]
- 실무에서 사용 불가능
- Product역할을 하는 엔티티를 직접 생성하고 다대일, 일대다 매핑으로 극복한다

## 고급 매핑
엔티티 클래스는 엔티티나 @MappedSuperclass로 지정한 클래스만 상속 가능 
### 상속관계 매핑
#### @Inheritance(strategy=InheritanceType.XXX)
1. JOINED : 조인 전략 -> 각각 테이블로 변환
  - 테이블 정규화
  - 외래 키 참조 무결성 제약조건 활용가능
  - 저장공간 효율화
  - 중요도가 높은 엔티티의 경우 사용
2. SINGLE_TABLE : 단일 테이블 전략 -> 통합 테이블로 변환
  - 조인이 없으므로 조회 성능 빠름
  - 단순한 엔티티의 경우 사용

#### DiscriminatorColumn(name="DTYPE")
부모 테이블에서 자식들의 구분을 위한 필드 생성

#### @MappedSuperclass
- 공통 매핑 정보가 필요할 때 사용
- 상속관계 매핑 X
- 엔티티 X, 테이블과 매핑 X
- 자식 클래스에 매핑 정보만 제공
- 조회, 검색 불가
- 추상 클래스 권장

## 프록시와 연관관계 관리
### 프록시 기초
- 데이터 베이스의 조회를 미루는 가짜 엔티티 객체를 생성한다

### 프록시 특징
- 실제 클래스를 상속 받아서 만들어진다
- 실제 객체의 타겟을 보관한다
- 프록시를 호출하면 실제 객체인 타겟을 호출한다
- 초기 호출 한 번만 초기화한다
- 초기화되면 실제 객체에 접근이 가능해진다
- 타입 체크는 instance of 사용
- 초기화 후에는 영속성 컨텍스트에 타겟이 존재하므로 프록시 호출시 실제 객체가 호출된다
- 준영속 상황에 프록시를 초기화하면 org.hibernate.LazyInitializationException 예외가 나온다

### 지연 로딩과 즉시 로딩
- 가급적 지연 로딩만 사용
- 즉시 로딩은 JPQL에서 N+1 문제를 일으킨다

### 영속성 전이 (CASCADE)
- 부모 엔티티를 저장할 때 자식 엔티티도 함께 저장할 때 사용
- ALL : 모두 적용, PERSIST : 영속, REMOVE : 삭제

### 고아 객체
- orphanRemoval = true : 부모 엔티티와 연관관계가 끊어진 자식 엔티티를 자동으로 삭제
- 참조하는 곳이 하나일 때 사용해야함
- 특정 엔티티가 개인 소유할 때 사용

### CascadeType.ALL + orphanRemovel=true
- 두 옵션을 모두 활성화 하면 부모 엔티티를 통해서 자식의 생명 주기를 관리할 수 있음
- 도메인 주도 설계(DDD)의 Aggregate Root개념을 구현할 때 유용
