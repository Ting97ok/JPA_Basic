# JPA_Basic
## JPA 소개
### SQL 중심적인 개발의 문제점
- 객체답게 모델링 할수록 매핑 작업만 늘어난다
- 무한 반복, 지루한 코드
- 필드 추가시 모든 관련 SQL 쿼리 수정

#### 객체와 관계형 데이터베이스의 차이
- 상속
- 연관관계 : 객체 = 단방향 / 테이블 = 양방향
- 데이터 타입
- 데이터 식별 방법

### JPA
- 자바 진영의 ORM 기술 표준
- 애플리케이션과 JDBC 사이에서 동작
- 엔티티를 분석해서 SQL 생성
- SQL를 생성해서 엔티티로 결과반환
- JPA는 인터페이스의 모음
- JPA 표준 명세를 구현한 3가지 구현체
  - 하이버네이트 
  - EclipseLink
  - DataNucleus 

#### ORM
- 객체 관계 매핑
- 객체는 객체대로 설계
- 관계형 데이터베이스는 관계형 데이터베이스대로 설계
- ORM 프레임워크가 중간에서 매핑

#### JPA를 왜 사용해야 하는가?
- 객체 중심으로 개발 가능
- 생산성
- 유지보수
- 패러다임의 불일치 해결
  - 상속 
    - 저장 : 부모 insert문 자식 insert문 생성
    - 조회 : 조인 쿼리문 생성
    - 연관관계, 객체 그래프 탐색 : 컬랙션 형태로 탐색가능
- 신뢰할 수 있는 엔티티, 계층
- JPA의 성능 최적화 기능
  - 1차 캐시와 동일성 보장 : 같은 트랜잭션 안에서는 같은 엔티티를 반환 = 한 번 실행한 SQL은 다시 실행 안한다
  - 트랜잭션을 지원하는 쓰기 지연 : 트랜잭션을 커밋할 때 까지 insert문을 모은다
  - 지연 로딩 : 객체가 실제 사용될 때 로딩
  - 즉시 로딩 : JOIN SQL로 한번에 연관된 객체까지 미리 조회

## JPA 시작하기
- 엔티티 매니저 팩토리는 하나만 생성해서 애플리케이션 전체에서 공유
- 엔티티 매니저는 쓰레드간의 공유 X (사용하고나면 버려야 한다)
- JPA의 모든 데이터 변경은 트랜잭션 안에서 실행

## 영속성 관리 - 내부 동작 방식
### 영속성 컨텍스트
- 엔티티를 영구 저장하는 환경
- 엔티티 매니저를 통해서 접근

#### 엔티티의 생명주기
- 비영속 : 영속성 컨텍스트와 전혀 관계 없는 새로운 상태
- 영속 : 영속성 컨텍스트에 관리되는 상태
- 준영속 : 영속성 컨텍스트에 저장되었다가 분리된 상태
- 삭제 : 삭제된 상태

#### 1차 캐시에서 조회
한 번 조회한 쿼리 데이터는 쿼리에 저장해놓고 중복 조회를 하지않는다

#### 영속 엔티티의 동일성 보장
한 번 조회한 것은 1차 캐시에서 가져오기 때문에 동일성이 보장된다

#### 트랜잭션을 지원하는 쓰기 지연 ( 엔티티 생성 )
insert 쿼리가 트랜잭션 커밋 시점에 실행된다.

#### 변경 감지 ( 엔티티 수정 )
1차캐시에 있는 데이터가 변경되면 update 쿼리 생성

### 플러시
영속성 컨텍스트의 변경내용을 데이터베이스에 반영  
트랜잭션이라는 작업 단위가 중요  
커밋 직전에만 동기화 하면 됨

#### 플러시 밣생
- 변경 감지
- 수정된 엔티티 쓰기 지연 SQL 저장소에 등록
- 쓰기 지연 SQL 저장소의 쿼리를 데이터베이스에 전송(등록, 수정, 삭제 쿼리)

#### 영속성 컨텍스트를 플러시하는 방법
- em.flush() : 직접 호출
- 트랜잭션 커밋 : 플러시 자동 호출
- JPQl 쿼리 실행 : 플러시 자동 호출

### 준영속 상태
영속성 컨텍스트의 기능을 사용하지 못하게 된다

#### 준영속 상태 만드는법
- em.detach : 특정 엔티티만 준영속 상태 만들기
- em.clear : 영속성 컨텍스트 완전 초기화
- em.close : 영속성 컨텍스트 종료

## 엔티티 매핑
### 엔티티 매핑 소개
- 객체와 테이블 매핑 : @Entity, @Table
- 필드와 컬럼 매핑 : @Column
- 기본 키 매핑 : @Id
- 연관관계 매핑 : @ManyToOne, @JoinColumn

### @Entity : JPA가 관리하는 엔티티
- 기본 생성자 필수( 파라미터가 없는 public 또는 protected 생성자)
- final 클래스, enum, interface, inner 클래스 사용 X
- 저장할 필드에 final 사용 X

### @Table : 엔티티와 매핑할 테이블 지정
속성 리스트
- name : 매핑할 테이블 이름
- catalog : DB catalog 매핑
- schema : DB 스키마 매핑
- uniqueConstraints : DDL 생성 시에 유니크 제약 조건 생성

### 데이터베이스 스키마 자동 생성
- DDL을 애플리케이션 실행 시점에 자동 생성
- 테이블 중심 -> 객체 중심
- 데이터베이스 방언을 활용해서 적절한 DDL 생성
- DDL은 개발 장비에서만 사용
- DDL은 운영서버에서는 사용하지 않거나, 적절히 다듬은 후 사용

#### 속성
hibernate.hbm2ddl.auto
- create : 기존테이블 삭제 후 다시 생성
- create-drop : create와 같으나 종료시점에 테이블 drop
- update : 변경분만 반영(운영DB에는 사용하면 안됨)
- validate : 엔티티와 테이블이 정상 매핑되었는지만 확인
- none : 사용하지않음

#### 주의
- create, create-drop, update는 운영 장비에는 절대 사용하면 안된다
- 개발 초기 단계 : create, update
- 스테이징과 테스트 서버 : update, validate
- 운영 서버 : none

### 필드와 컬럼 매핑
- @Column : 컬럼 매핑
- @Temporal : 날짜 타입 매핑
- @Enumerated : enum 타입 매핑
- @Lob : BLOB, CLOB 매핑
- @Transient 특정 필드를 컬럼에 매핑하지 않음

#### @Column
속성
- name : 필드와 매핑할 테이블의 컬럼 이름
- insertable, updatable : 등록, 변경 기능 여부
- nullable(DDL) : null 값의 허용 여부를 설정한다
- unique(DDL) : 한 컬럼에 간단히 유니크 제약조건을 걸 때 사용 (@Table의 uniqueConstraints를 쓰고 해당 속성은 잘 사용하지 않는다)
- columnDefinition(DDL) : 데이터베이스 컬럼 정보를 직접 줄 수 있다.
- length(DDL) : 문자 길이 제약조건, String 타입에만 사용가능
- precision, scale(DDL) : 매우 큰 숫자나 정밀한 소수를 다룰 때 사용(precision은 소수점을 포함한 전체 자릿수, scale은 소수의 자릿수)

##### @Temporal
날짜 타입을 매핑할 때 사용  
LocalDate, LocalDateTime을 사용할 때는 생략  
속성
- value
  - TemporalType.DATE : 예) 2013-10-11
  - TemporalType.TIME : 예) 11:11:11
  - TemporalType.TIMESTAMP : 예) 2013-10-11 11:11:11

#### @Enumerated
EnumType.ORDINAL은 사용하지 않는다

#### @Lob
매핑하는 필드 타입이 문자면 CLOB 나머지는 BLOB

#### @Transient
메모리상에서만 임시로 값을 보관하고 싶을 때 사용

### 기본 키 매핑
#### 기본 키 매핑 어노테이션
- @Id
- @GeneratedValue

#### 기본 키 매핑 방법
- 직접 할당 : @Id만 사용
- 자동 생성(@GeneratedValue)
  - IDENTITY: 데이터베이스에 위임, MYSQL (ID값을 알기 위해 지연 로딩 사용 불가)
  - SEQUENCE: 데이터베이스 시퀀스 오브젝트 사용, ORACLE
    - @SequenceGenerator 필요
    - allocationSize 속성으로 미리 지정한 갯수만큼 불러와서 메모리에서만 사용하는 식으로 최적화 가능
  - TABLE: 키 생성용 테이블 사용, 모든 DB에서 사용
    - @TableGenerator 사용
    - allocationSize 속성으로 미리 지정한 갯수만큼 불러와서 메모리에서만 사용하는 식으로 최적화 가능
  - AUTO: 방언에 따라 자동 지정, 기본값

#### 권장하는 식별자 전략
Long형 + 대체키 + 키 생성전략 사용

## 연관관계 매핑 기초
### 양방향 매핑 규칙
- 객체의 두 관계중 하나를 연관관계의 주인으로 지정
- 연관관계의 주인만이 외래 키를 관리
- 주인이 아닌쪽은 읽기만 가능
- 주인은 mappedBy 속성 사용 X
- 주인이 아니면 mappedBy 속성으로 주인 지정
- FK가 있는 엔티티를 주인으로 정해라

### 양방향 연관관계 주의
- 순수 객체 상태를 고려해서 항상 양쪽에 값을 설정하자
- 연관관계 편의 메소드를 생성하자 예) Member클래스에 setTeam메서드 team.getMembers().add(this);
- 양방향 매핑시에 무한 루프를 조심하자

### 양방향 매핑 정리
- 설계 시점에 단방향 매핑만으로 끝낸다
- 반대 방향은 조회 기능만 추가한다는 생각으로 추가한다
- 